import os
import time
from pathlib import Path # a class to handle os paths
import logging
import platform, sys
from simulation.parallel_with_threads import run_parallel

from simulation.evaluate import evaluate_and_assign_folder

finished_logname = "finished.log"
sim_logname = 'sim.log'


# Helpers
def hibernate(delay=10):
    '''
    For the option to hibernate after
    '''
    for k in range(delay):
        print("Hibernation in {0} seconds..".format(delay - k))
        time.sleep(1)
    os.system("shutdown.exe /h")

def datestamp():
    return time.strftime("%Y-%m-%d")

def _log_metadata_and_start_message(num_processes, logger):
    python_version = "Python " + sys.version
    os_info = platform.platform()
    pc_name = platform.node()

    logger.info(python_version)
    logger.info("%s %s", pc_name, os_info)
    if num_processes > 1:
        logger.info("Start: Run simulations on with %d threads", num_processes)
    else:
        logger.info("Start: Run simulations on with %d thread", num_processes)


def _log_finish_message(logger):
    pc_name = platform.node()
    logger.info("Finish: Run simulations on '%s'", pc_name)


## Exception Handler as described here
## https://stackoverflow.com/questions/8050775/using-pythons-logging-module-to-log-all-exceptions-and-errors
## Didn't see any changes after using this function -> commented it out.
## Still need a way to log exceptions
# def _initalize_exception_handler(logger):
#     def my_handler(type, value, tb):
#         logger.exception("Uncaught exception: {0}".format(str(value)))
#
#     # Install exception handler
#     sys.excepthook = my_handler

def run_parallel_and_log(basic_folder, function_to_run, subfolder_generator,
                         list_of_args=None, list_of_kwargs=None,
                         num_processes=2,
                         logger=None):
    if logger == None:
        logger = logging.getLogger('null')  # create a logger

    finished_info = open(basic_folder / finished_logname, 'a')

    def run_in_simulation_folder(*args, **kwargs):
        '''
        Generate folder with supplied generator and run simulation
        '''
        subfolder = subfolder_generator(*args, **kwargs)
        folder = basic_folder / subfolder

        logger.info("Start:  Simulation in '%s'", subfolder)
        result = function_to_run(*args, folder=folder, **kwargs)
        logger.info("Finish: Simulation in '%s'", subfolder)

        finished_info.write(str(subfolder) + '\n')
        return result

    # Run simulations
    _log_metadata_and_start_message(num_processes, logger)
    run_parallel(num_processes, run_in_simulation_folder, list_of_args, list_of_kwargs)
    _log_finish_message(logger)

    finished_info.close()


class Simulation:
    '''
    The class to run a function with different arguments in parallel -> see __init__, see example in the end of file
    '''

    def __init__(self, function_to_run, parent_folder,
                 name,
                 subfolder_generator,
                 args_list=None, kwargs_list=None):
        """
        :param function_to_run: f(*args, folder=None): takes `folder` as a keyword argument;
                                This is a folder where the simulation results will be saved.
        :param subfolder_generator: Takes all the arguments of the function_to_run, except `folder`;
            Returns `folder`; `folder` - whould be normally a place where the simulation function would save the results.
        args_list, kwargs_list - arguments and keyword arguments to run the function.
        Except the `folder`! Which is generated by `subfolder_generator`
        """
        self.function_to_run = function_to_run
        # Check that input is correct
        if args_list == None and kwargs_list == None:
            raise ValueError('Both args and kwargs are None')
        elif args_list == None:
            args_list = [[] for i in range(len(kwargs_list))]
        elif kwargs_list == None:
            kwargs_list = [{} for i in range(len(args_list))]
        elif len(args_list) != len(kwargs_list):
            raise ValueError('List of args and list of kwargs have different length')
        self.args_list = args_list
        self.kwargs_list = kwargs_list

        self.subfolder_generator = subfolder_generator

        self.parent_folder = Path(parent_folder)
        self.name = name
        self.basic_folder = None
        # Logging
        self._logger = None
        self._log_handler = None
        self._formatter = None

    def evaluate_given_args(self, *args, **kwargs):
        '''
        output - folder name
        '''
        return evaluate_and_assign_folder(self.function_to_run, *args,
                                          folder_generator=self.subfolder_generator, input_space=self.args_list,
                                          **kwargs)

    def evaluate(self, id=None, pick_random=False):
        '''
        output - folder name
        '''
        if pick_random == True:
            import random
            id = random.randint(0, len(self.args_list) - 1)

        return self.evaluate_given_args(*self.args_list[id], **self.kwargs_list[id])

    # def _write_metadata(self, filename):
    #     pass
    # metadata_filename = basic_folder / 'info.txt'
    # self._write_metadata(metadata_filename)
    def get_basic_folder(self, add_datestamp=True, date=None):
        if add_datestamp:
            if date is None:
                date = datestamp()
            folder_name = "{0}_{1}".format(date, self.name)
            self.basic_folder = self.parent_folder / folder_name
        else:
            self.basic_folder = self.parent_folder / self.name
        return self.basic_folder

    def _setup_logging(self, filename, mode='a', print_log_messages=True):
        self._logger = logging.getLogger("")  # Use root logger
        #  logging.getLogger(self.name) # or use a named one?
        # Clear previous handlers, if any
        if (self._logger.hasHandlers()):
            self._logger.handlers.clear()
        # Formatter
        self._formatter = logging.Formatter('{asctime} {levelname} {threadName} {name} {message}', style='{')
        # Handler
        self._log_handler = logging.FileHandler(filename, mode=mode)
        self._logger.addHandler(self._log_handler)
        self._log_handler.setFormatter(self._formatter)
        if print_log_messages:
            stream_handler = logging.StreamHandler(sys.stdout)
            stream_handler.setFormatter(self._formatter)
            self._logger.addHandler(stream_handler)
        # Set level - pass all messages with level INFO or higher (WARNING, ERROR, CRITICAL)
        self._logger.setLevel(logging.INFO)
        self._log_handler.setLevel(logging.INFO)

        # Catch exceptions - doesn't work? Commented out
        # _initalize_exception_handler(self._logger)

        # logging.getLogger('').addHandler(self._log_handler)
        #   self._logger.propagate = False # Otherwise duplicates messages ?!
        return self._logger, self._log_handler

    def list_finished(self):
        '''
        Tested. Returns a list of subfolders, where jobs were finished
        '''
        with open(self.basic_folder / finished_logname, 'r') as finished_info:
            subfolders = finished_info.readlines()
            subfolders = [x.strip("\n") for x in subfolders]  # Remove line separators
            subfolders = [Path(subfolder) for subfolder in subfolders]
        return subfolders

    def list_unfinished(self, ignore_remove_error=False):
        all_folders = [Path(self.subfolder_generator(*args, **kwargs))
                       for args, kwargs in zip(self.args_list, self.kwargs_list)]
        finished = self.list_finished()
        for f in finished:
            try:
                all_folders.remove(f)
            except:
                if ignore_remove_error:
                    continue
                else:
                    logging.error("Couldn't find {} in the input folders list".format(f))
                    raise
        return all_folders

    def list_unfinished_args_kwargs(self, ignore_remove_error=False):
        '''
        Note: it's not very fast function when the list is long.
        '''
        unfinished_subfolders = self.list_unfinished(ignore_remove_error=ignore_remove_error)
        unfinished_args, unfinished_kwargs = [], []
        for args, kwargs in zip(self.args_list, self.kwargs_list):
            subfolder_generated = Path(self.subfolder_generator(*args, **kwargs))
            for subfolder in unfinished_subfolders:
                if subfolder_generated == subfolder:
                    unfinished_args.append(args)
                    unfinished_kwargs.append(kwargs)
                    break
        return unfinished_args, unfinished_kwargs

    def run_all(self, num_processes=1, add_datestamp=True, hibernate_flag=False,
                print_log_messages=True, start_message=None):
        '''
        Run all simulations with proper logging,
        add kwarg 'folder' to the function running?
        :param add_datestamp: if True - add date in the beginning of the folder name
        '''
        if self.basic_folder is None:
            self.get_basic_folder(add_datestamp)

        os.makedirs(self.basic_folder, exist_ok=True)

        logname = self.basic_folder / sim_logname
        self._setup_logging(logname, mode='w', print_log_messages=print_log_messages)
        if start_message is not None:
            self._logger.info(start_message)
        run_parallel_and_log(basic_folder=self.basic_folder,
                             function_to_run=self.function_to_run,
                             subfolder_generator=self.subfolder_generator,
                             list_of_args=self.args_list,
                             list_of_kwargs=self.kwargs_list,
                             num_processes=num_processes,
                             logger=self._logger)

        if hibernate_flag is True:
            hibernate(delay=10)

    def run_unfinished(self, num_processes=1, hibernate_flag=False, print_log_messages=True, date=None,
                       start_message=None, ignore_remove_error=False):
        '''
        Have to specify 'date', if the original simulation foldername included datestamp
        date in the form: '2018-12-31'
        '''
        if self.basic_folder is None:
            if date is None:
                self.get_basic_folder(add_datestamp=False)
            else:
                self.get_basic_folder(add_datestamp=True, date=date)
        # Find input values for unfinished simulations
        unfinished_args, unfinished_kwargs = self.list_unfinished_args_kwargs(ignore_remove_error=ignore_remove_error)

        logname = self.basic_folder / sim_logname
        self._setup_logging(logname, mode='a', print_log_messages=print_log_messages)
        if start_message is not None:
            self._logger.info(start_message)
        run_parallel_and_log(basic_folder=self.basic_folder,
                             function_to_run=self.function_to_run,
                             subfolder_generator=self.subfolder_generator,
                             list_of_args=unfinished_args,
                             list_of_kwargs=unfinished_kwargs,
                             num_processes=num_processes,
                             logger=self._logger)

        if hibernate_flag is True:
            hibernate(delay=10)


if __name__ == '__main__':
    # Run some tests.
    import math


    def f(x, y, folder):
        filename = folder / "res.txt"
        os.makedirs(folder,exist_ok=True)
        with open(filename, 'w') as file:
            for j in range(int(y)):
                sum = 0
                for i in range(int(x)):
                    sum += math.log(x ** y)
                    sum = math.sin(sum)
                file.write(str(sum))
                file.write("\n")
        # # Test exception handler
        # try:
        #     if x == 4:
        #         raise ValueError("1234")
        # except ValueError:
        #     pass
        # if x == 5:
        #     raise ValueError("12345")
        time.sleep(1)
        return None


    def subfolder_generator(x, y):
        return "{:.2f}".format(x)


    list_of_args = [[x, 100] for x in range(10)]

    parent_folder = 'data'
    name = 'test1'
    # Define simulation class
    s = Simulation(f, parent_folder, name, subfolder_generator, list_of_args)

    # Test evaluate
    # s.evaluate_one_from_the_list(pick_random=True)
    # Test run_all
    s.run_all(num_processes=2, add_datestamp=False, print_log_messages=True,
              start_message=__file__)

    s.get_basic_folder(add_datestamp=False)
    # print(s.list_unfinished())
    # date = None # "2018-07-13"
    # s.run_unfinished(date=date, start_message=__file__, ignore_remove_error=True)
    #
    # # List all loggers
    # loggers_dict = logging.Logger.manager.loggerDict
    # for logger in loggers_dict.values():
    #     print(logger.handlers)
